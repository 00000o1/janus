<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebRTC Server Page</title>
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>
</head>
<body>
  <h1>WebRTC 'Server'</h1>
  <section id="blog">
    <!-- Example blog content ( this whole blog section element will be sent over the wire ) -->
    <style>
        /* Basic styles for blog */
        #blog {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 20px auto;
        }
        .article {
            margin-bottom: 40px;
        }
        .article h2 {
            color: #333;
        }
        .article p {
            color: #666;
        }
    </style>
    <div class="article">
        <h2>Exploring the Mysteries of UFOs</h2>
        <p>Written by AI: Unidentified Flying Objects have always stirred the curiosity of humankind. Are we alone in the universe or is there life beyond our planet?...</p>
    </div>
    <div class="article">
        <h2>The Joy of Cooking</h2>
        <p>Written by AI: Cooking is not just a necessity; it's an art. Exploring different cuisines opens up a world of flavors and experiences...</p>
    </div>
    <div class="article">
        <h2>Latest Gadgets in Tech</h2>
        <p>Written by AI: The world of technology is ever-evolving, and the latest gadgets offer a glimpse into the future. From AI-driven devices to smart home systems...</p>
    </div>
    <div class="article">
        <h2>Best Books to Read This Year</h2>
        <p>Written by AI: Whether you're into fiction, non-fiction, or anything in between, there's always a good book waiting to be read. Here are some top picks for the year...</p>
    </div>
    <div class="article">
        <h2>Traveling the World</h2>
        <p>Written by AI: Traveling opens up new horizons, offering a glimpse into diverse cultures, landscapes, and experiences. Let's explore some must-visit destinations...</p>
    </div>
    <div class="article">
        <h2>Developer Topics: Staying Ahead</h2>
        <p>Written by AI: In the ever-changing world of software development, staying updated with the latest trends and technologies is key. Let's dive into some important topics for developers...</p>
    </div>
  </section>
  <script>
    // Parse URL parameters to get GitHub credentials
    const urlParams = new URLSearchParams(window.location.search);
    const ghCreds = JSON.parse(decodeURIComponent(urlParams.get('ghCreds')));
    const ghAccessToken = ghCreds.GH_ACCESS_TOKEN;
    const repoUrl = ghCreds.REPO_URL;

    const [ username, repoName ] = new URL(repoUrl).pathname.split('/').filter(part => part.length);

    let clients = {}; // Map to hold ghUsername to peer mapping

    // Function to send message to a specific client
    window.sendMessageToClient = (ghUsername, message) => {
      const peer = clients[ghUsername];
      if (peer) {
        peer.send({type: 'chat', msg: message, handle: ghUsername});
      } else {
        console.error('Client not found:', ghUsername);
      }
    };

    window.ghAccessToken = ghAccessToken;
    window.repoUrl = repoUrl;
    if (!ghAccessToken) {
      console.error('GitHub access token not found!');
    } else {
      console.log('GitHub access token retrieved.');
      pollGitHubAPI(repoUrl, ghAccessToken);
    }

    async function pollGitHubAPI(repoUrl, accessToken) {
      repoUrl = new URL(repoUrl.replace(/\/$/, '')).href;
      let lastChecked = new Date().toISOString();
      let processedIssues = new Set(); // Set to keep track of processed issues

      setInterval(async () => {
        const response = await fetch(`https://api.github.com/repos/${username}/${repoName}/issues?since=${lastChecked}&state=open`, {
          headers: {
            'Authorization': `token ${accessToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        const issues = await response.json();

        if (issues.length > 0) {
          console.log('New issues:', issues.map(issue => `#${issue.number}`));
          for (const issue of issues) {
            if (processedIssues.has(issue.number)) {
              continue; // Skip already processed issues
            }

            const ghUsername = issue.user.login; // Extract GitHub username
            const commentsResponse = await fetch(issue.comments_url, {
              headers: {
                'Authorization': `token ${accessToken}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            });
            const comments = await commentsResponse.json();
            const webrtcResponseComment = comments.find(comment => isResponseComment(comment));

            if (webrtcResponseComment) {
              processResponseComment(webrtcResponseComment, ghUsername);
              closeIssue(issue.number, repoUrl, accessToken); // Close the issue after processing the comment
            } else {
              const postComment = createCommentPoster(issue.number, repoUrl, accessToken, ghUsername);
              await beginConnectionProcess(postComment, ghUsername); // Open new connection
            }

            processedIssues.add(issue.number);
            await sleep(200);
          }
          lastChecked = new Date().toISOString();
        }
      }, 15051);
    }

    function isResponseComment(comment) {
      // Determine if the comment is a WebRTC response
      return comment.body.startsWith('janus://calling-from/');
    }

    function processResponseComment(comment, ghUsername) {
      const signalData = extractSignalDataFromComment(comment.body);
      const peer = clients[ghUsername];
      if (peer) {
        peer.signal(signalData);
      } else {
        console.error('No peer connection found for username:', ghUsername);
      }
    }

    function extractSignalDataFromComment(commentBody) {
      // Assuming the signaling data is JSON encoded within the comment body
      const signalDataString = commentBody.replace('janus://calling-from/', '').trim();
      return JSON.parse(atob(signalDataString));
    }

    async function closeIssue(issueNumber, repoUrl, accessToken) {
      const closeIssueUrl = `https://api.github.com/repos/${username}/${repoName}/issues/${issueNumber}`;
      const body = {
        state: 'closed'
      };

      try {
        const response = await fetch(closeIssueUrl, {
          method: 'PATCH',
          headers: {
            'Authorization': `token ${accessToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        if (!response.ok) {
          console.error('Failed to close issue:', await response.text());
        } else {
          console.log(`Issue #${issueNumber} closed successfully.`);
        }
      } catch (error) {
        console.error('Error closing issue:', error);
      }
    }

    function createCommentPoster(issueNumber, repoUrl, accessToken) {
      return async (signalData) => {
        const staticSiteUrl = formatStaticSiteUrl(repoUrl, signalData, `${repoUrl}/issues/${issueNumber}`);
        console.log({staticSiteUrl});
        await postCommentToIssue(issueNumber, staticSiteUrl, repoUrl, accessToken);
      };
    }

    function formatStaticSiteUrl(repoUrl, signalData, issueUrl) {
      const [ userName, repoName ] = new URL(repoUrl).pathname.split('/').filter(part => part.length);
      const encodedSignalData = encodeURIComponent(JSON.stringify(signalData));
      const encodedIssueUrl = encodeURIComponent(issueUrl);
      return `https://${userName}.github.io/${repoName}?data=${encodedSignalData}&issue=${encodedIssueUrl}`;
    }

    async function postCommentToIssue(issueNumber, commentUrl, repoUrl, accessToken) {
      const markdownLink = `[janus://dials/${username}](${commentUrl})`;
      try {
        const commentResponse = await fetch(`https://api.github.com/repos/${username}/${repoName}/issues/${issueNumber}/comments`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${accessToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ body: markdownLink })
        });

        if (!commentResponse.ok) {
          console.error('Failed to post comment:', await commentResponse.text());
        } else {
          console.log('Comment posted successfully.');
        }
      } catch(e) {
        console.warn(`Error posting comment`, e);
      }
    }

    async function beginConnectionProcess(postComment, ghUsername) {
      // Create a new peer as the initiator
      let resolve;
      const pr = new Promise(res => resolve = res);
      try {
        const peer = new SimplePeer({ 
          initiator: true, 
          trickle: false,
          channelConfig: {
            ordered: true,
            maxRetransmits: 0,
          }
        });
        clients[ghUsername] = peer;

        let dataChannel;

        // When the peer generates a signaling data (offer), log it
        peer.on('signal', data => {
          console.log('Signal data:', JSON.stringify(data));
          // Send this data back to your server or GitHub as needed
          postComment(data).then(resolve);
        });

        // When peer connection is established
        peer.on('connect', () => {
          console.log('New client connected!', ghUsername);
          dataChannel = peer; // In SimplePeer, peer itself acts as a data channel
          dataChannel.send({type: 'chat', msg: `Hello ${ghUsername} from the WebRTC "server"!`});
          dataChannel.send({type: 'blog', content: document.querySelector('section#blog').outerHTML });
        });

        // Receiving messages on the data channel
        peer.on('data', data => {
          try {
            const message = JSON.parse(data.toString());
            if (message.type === 'chat') {
              // Format the chat message for better readability in the console
              console.log(`CHAT_MSG [${message.ghUsername}]: ${message.msg}`);
            } else {
              // For other types of messages, log them as is
              console.log('Received message:', message);
            }
          } catch (e) {
            console.error('Error parsing received message:', e);
          }
        });

        // Handling errors
        peer.on('error', err => {
          console.error('WebRTC Error:', err);
          resolve();
        });
      } catch(e) {
        console.warn(`Error creating peer`, e);
        resolve();
      }
      
      return pr;
    }

    async function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }
  </script>
</body>
</html>

